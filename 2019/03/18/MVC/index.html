<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>
</script>







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Servlet," />










<meta name="description" content="前言：我为什么要去学这些东西呢？ 以前你问我MVC是什么，相信我肯定可以回答出（Model—View—Controller）然后,然后我就什么就不知道了….这其中涉及到哪些思想，哪些具体的东西，我是一概不知的。">
<meta name="keywords" content="Servlet">
<meta property="og:type" content="article">
<meta property="og:title" content="MVC-Servlet">
<meta property="og:url" content="http://yoursite.com/2019/03/18/MVC/index.html">
<meta property="og:site_name" content="YAO">
<meta property="og:description" content="前言：我为什么要去学这些东西呢？ 以前你问我MVC是什么，相信我肯定可以回答出（Model—View—Controller）然后,然后我就什么就不知道了….这其中涉及到哪些思想，哪些具体的东西，我是一概不知的。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/03/18/MVC/1.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/18/MVC/2.png">
<meta property="og:image" content="http://yoursite.com/2019/03/18/MVC/3.png">
<meta property="og:image" content="http://yoursite.com/2019/03/18/MVC/4.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/18/MVC/5.png">
<meta property="og:image" content="http://yoursite.com/2019/03/18/MVC/6.png">
<meta property="og:image" content="http://yoursite.com/2019/03/18/MVC/7.png">
<meta property="og:image" content="http://yoursite.com/2019/03/18/MVC/8.png">
<meta property="og:image" content="http://yoursite.com/2019/03/18/MVC/9.png">
<meta property="og:image" content="http://yoursite.com/2019/03/18/MVC/10.png">
<meta property="og:image" content="http://yoursite.com/2019/03/18/MVC/11.png">
<meta property="og:image" content="http://yoursite.com/2019/03/18/MVC/12.png">
<meta property="og:image" content="http://yoursite.com/2019/03/18/MVC/13.png">
<meta property="og:image" content="http://yoursite.com/2019/03/18/MVC/14.png">
<meta property="og:updated_time" content="2019-04-10T11:45:36.729Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MVC-Servlet">
<meta name="twitter:description" content="前言：我为什么要去学这些东西呢？ 以前你问我MVC是什么，相信我肯定可以回答出（Model—View—Controller）然后,然后我就什么就不知道了….这其中涉及到哪些思想，哪些具体的东西，我是一概不知的。">
<meta name="twitter:image" content="http://yoursite.com/2019/03/18/MVC/1.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/18/MVC/"/>





  <title>MVC-Servlet | YAO</title>
  








  
  
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">



  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YAO</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Something I Like .</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/18/MVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YAO">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MVC-Servlet</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-18T22:22:27+08:00">
                2019-03-18
              </time>
            

            

            
          </span>
		  
		  
		  
  <span class="post-updated">
    &nbsp; | &nbsp; 更新于
    <time itemprop="dateUpdated" datetime="2019-04-10T19:45:36+08:00" content="2019-04-10">
      2019-04-10
    </time>
  </span>



          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MVC/" itemprop="url" rel="index">
                    <span itemprop="name">MVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  17,227
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  70
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>我为什么要去学这些东西呢？</p>
<p>以前你问我MVC是什么，相信我肯定可以回答出（Model—View—Controller）然后,然后我就什么就不知道了….这其中涉及到哪些思想，哪些具体的东西，我是一概不知的。</p>
<a id="more"></a>
<p>然后最开始接触javaWeb的时候撸了一些jsp后，写项目直接用了springboot，正所谓<em>springboot一时爽，一直springboot一直爽</em>。但是当我后面接触一个struts2的项目时我突然发现写Filter和interceptor后，完全不明白为什么要这么写，为什么这样就可以通过呢？那样就不可以呢？它究竟是通过什么来实现的呢？然后还有写完这些还要去配置web.xml（或许连xml文件都不是很看得懂）真的感觉很懵逼。突然就觉得自己好像什么都不会。然后恰逢看书时看到一句话：javaee的核心设计模式就是MVC，框架只是一种简单的应用。这使我发现我之前掌握的东西是真的很有问题的，于是我就开始了我的弥补之路。</p>
<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>Java EE中标准的MVC设计模式如下图</p>
<p><img src="/2019/03/18/MVC/1.jpg" alt=""></p>
<p>在标准的MVC设计模式中，用户一旦发出请求后会将所有的请求交给控制层处理，然后再由控制层调用模型层中的模型组件，并通过这些组件进行持久层的访问，再将所有结果保存在JavaBean中，最终由JSP和JavaBean一起完成页面的显示。虽然在不同的开发架构中会存在一些差别，但是只要掌握了这个标准，就可以很容易的上手其他的框架。</p>
<h2 id="初阶Servlet"><a href="#初阶Servlet" class="headerlink" title="初阶Servlet"></a>初阶Servlet</h2><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><h4 id="由上图可以看出控制层主要是Servlet，那么什么是Servlet呢？"><a href="#由上图可以看出控制层主要是Servlet，那么什么是Servlet呢？" class="headerlink" title="由上图可以看出控制层主要是Servlet，那么什么是Servlet呢？"></a>由上图可以看出控制层主要是Servlet，那么什么是Servlet呢？</h4><p>狭义的Servlet是指Java语言实现的一个接口（<strong>javax.servlet.Servle</strong>t），广义的Servlet是指任何实现了这个Servlet接口的类（<strong>javax.servlet.GenericServlet</strong> , <strong>javax.servlet.http.HttpServlet</strong> , <strong>还有其他继承了这些类的类</strong>），一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</p>
<p>Servlet带给人们最大的好处就是它可以处理客户端传来的HTTP请求，并返回一个响应。</p>
<h4 id="Servlet处理的基本流程："><a href="#Servlet处理的基本流程：" class="headerlink" title="Servlet处理的基本流程："></a>Servlet处理的基本流程：</h4><ol>
<li>客户端（很可能是web浏览器）通过HTTP提出请求.</li>
<li>web服务器接收该请求并将其发送给Servlet，如果这个Servlet尚未被加载，web服务器将把他加载到Java虚拟机并执行它</li>
<li>Servlet程序将接收该Http请求并执行某种处理。</li>
<li>Servlet会将处理后的结果向web服务器返回应答</li>
<li>web服务器将从Servlet收到的应答发回给客户端</li>
</ol>
<p>在整个Servlet中最重要的就是Servlet接口，在此接口下定义了一个GenericServlet子类，但是一般都不会继承此类，而是根据使用的协议选择GenericServlet的子类继承。例如现在采用的HTTP协议处理，所以一般而言当使用HTTP协议操作时用户自定义的Servlet都要继承HttpServlet类。</p>
<h4 id="关于-HttpServlet、GenericServlet-和-Servlet-的关系"><a href="#关于-HttpServlet、GenericServlet-和-Servlet-的关系" class="headerlink" title="关于 HttpServlet、GenericServlet 和 Servlet 的关系"></a>关于 HttpServlet、GenericServlet 和 Servlet 的关系</h4><h5 id="Servlet-1"><a href="#Servlet-1" class="headerlink" title="Servlet"></a>Servlet</h5><p>公共接口Servlet定义了所有Servlet必须实现的方法。</p>
<p>Servlet（javax.servlet.Servlet） 接口提供了五个方法，其中三个生命周期方法和两个普通方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.实例化（使用构造方法创建对象）</span></span><br><span class="line"><span class="comment"> * 2.初始化  执行init方法</span></span><br><span class="line"><span class="comment"> * 3.服务     执行service方法</span></span><br><span class="line"><span class="comment"> * 4.销毁    执行destroy方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生命周期方法:当Servlet第一次被创建对象时执行该方法,该方法在整个生命周期中只执行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生命周期方法:对客户端响应的方法,该方法会被执行多次，每次请求该servlet都会执行该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//生命周期方法:当Servlet被销毁时执行该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a>GenericServlet</h5><p>GenericServlet （javax.servlet.GenericServlet）是一个抽象类，实现了 Servlet 接口，并且对其中的 init() 和 destroy() 和 service() 提供了默认实现。在 GenericServlet 中，主要完成了以下任务：</p>
<ul>
<li>将 init() 中的 ServletConfig 赋给一个类级变量，可以由 getServletConfig 获得；</li>
<li>为 Servlet 所有方法提供默认实现；</li>
<li>可以直接调用 ServletConfig 中的方法；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>,<span class="title">ServletConfig</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//GenericServlet通过将ServletConfig赋给类级变量</span></span><br><span class="line">   <span class="keyword">private</span> trServletConfig servletConfig;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.servletConfig=servletConfig;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       自定义init()的原因是：如果子类要初始化必须覆盖父类的init() 而使它无效 这样</span></span><br><span class="line"><span class="comment">       this.servletConfig=servletConfig不起作用 ，此时servletConfig=null</span></span><br><span class="line"><span class="comment">       这样就会导致在其他方法中使用servletConfig进行一系列操作的代码发生空指针异常</span></span><br><span class="line"><span class="comment">       这样如果子类要初始化，可以直接覆盖不带参数的init()方法 </span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">this</span>.init();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//自定义的init()方法，可以由子类覆盖  </span></span><br><span class="line">   <span class="comment">//init()不是生命周期方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//实现service()空方法，并且声明为抽象方法，强制子类必须实现service()方法 </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request,ServletResponse response)</span> </span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> ServletException,java.io.IOException</span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//实现空的destroy方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是 GenericServlet 的大致实现思想，可以看到如果继承这个类的话，我们必须重写 service() 方法来对处理请求。</p>
<font size="4" color="red">注：在GenericServlet中有两个init方法(),一个为没带参数（非生命周期方法），一个为带参数（生命周期方法）,在我们自定义Servlet继承于它的时候，尽量不要去覆写生命周期init()方法。而是覆写非生命周期init()方法进行初始化。因为覆盖父类的生命周期方法init() 而使它无效 这样<br>       this.servletConfig=servletConfig不起作用 ，此时servletConfig=null<br>       这样就会导致在其他方法中使用servletConfig进行一系列操作的代码发生空指针异常</font>

<h5 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h5><p>HttpServlet （ javax.servlet.http.HttpServlet）也是一个抽象类，它进一步继承并封装了 GenericServlet，使得使用更加简单方便，由于是扩展了 Http 的内容，所以还需要使用 HttpServletRequest 和 HttpServletResponse，这两个类分别是 ServletRequest 和 ServletResponse 的子类。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//HttpServlet中的service()</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest httpServletRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">                       HttpServletResponse httpServletResponse)</span></span>&#123;</span><br><span class="line">        <span class="comment">//该方法通过httpServletRequest.getMethod()判断请求类型调用doGet() doPost()</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//必须实现父类的service()方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest,ServletResponse servletResponse)</span></span>&#123;</span><br><span class="line">      HttpServletRequest request;</span><br><span class="line">      HttpServletResponse response;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         request=(HttpServletRequest)servletRequest;</span><br><span class="line">         response=(HttpServletResponse)servletResponse;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ClassCastException)&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"non-http request or response"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//调用service()方法</span></span><br><span class="line">      <span class="keyword">this</span>.service(request,response);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，HttpServlet 中对原始的 Servlet 中的方法都进行了默认的操作，不需要显式的销毁初始化以及 service()，在 HttpServlet 中，自定义了一个新的 service() 方法，其中通过 getMethod() 方法判断请求的类型，从而调用 doGet() 或者 doPost() 处理 get,post 请求，使用者只需要继承 HttpServlet，然后重写 doPost() 或者 doGet() 方法处理请求即可。</p>
<p>我们一般都使用继承 HttpServlet 的方式来定义一个 servlet。</p>
<h4 id="Servlet的运行环境"><a href="#Servlet的运行环境" class="headerlink" title="Servlet的运行环境"></a>Servlet的运行环境</h4><font size="5" color="red"><strong>注</strong>：为了更好的了解Servlet,以下所有的Servlet都是通过实现javax.servlet.Servlet来展示，因为公共接口Servlet定义了所有Servlet必须实现的方法。所以了解了这个接口对后面的所有实现这个接口的Servlet理解将会变得十分容易</font>

<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>Servlet就像其他任何的Java程序，只需要通过JAVAC编译Servlet，在编译之后在经过web容器的一些配置就可以访问了。</p>
<p>注：在编译的时候可能会出现的错误提示，软件包javax.servlet不存在，软件包java.servlet.http不存在，这是因为Servlet的开发包保存在web容器的\lib下面，而使用javac的时候属于javase的环境编译，但是Servlet本身已经属于了Javaee的应用范畴，所以此时可以通过系统环境变量classpath将此开发包添加进来。当然如果你是使用IDE的话那么肯定会用更简洁的方式。</p>
<p>下面就来看一个简单的Servlet</p>
<p>ServletDemo.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig servletConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> servletConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servletConfig = servletConfig;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletConfig servletConfig = getServletConfig();</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);<span class="comment">//设置响应内容类型，告诉浏览器内容类型为HTML</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 调用ServletResponse的getWriter方法，他返回了一个可以向客户端发送文本的java.io.PrintWriter。默认使用ISO-8859-1编码</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">"&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;"</span> + <span class="string">"hello Servlet"</span> + <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"555555555"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在写好了一个Servlet程序，并对它编译之后，我们该如何去访问呢？我们可以发现无法对这个程序进行直接的访问，因为所有的Servlet程序都是以.class的形式存在的，所以必须在web.xml（具体哪个目录的xml后面有解释）文件中进行servlet程序的映射配置</p>
<p>配置如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span><span class="comment">&lt;!-- 定义servlet--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span><span class="comment">&lt;!-- 与servlet-mapping相对应--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span><span class="comment">&lt;!-- 定义包.类名称--&gt;</span></span><br><span class="line">      ServletDemo<span class="comment">&lt;!-- 我这个Servlet没有包所以直接写类名--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span><span class="comment">&lt;!-- 映射路径--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span><span class="comment">&lt;!-- 与servlet相对应--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span><span class="comment">&lt;!-- 页面的映射路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的配置是，用过/helloServlet路径即可找到对应的<servlet>节点，并找到<servlet-class>所指定的Servlet程序的“包.类”名称，然后启动服务器以后输入“ http:localhost:8080/hello”即可访问到该页面，你会发现此时浏览器显示如下</servlet-class></servlet></p>
<p><img src="/2019/03/18/MVC/2.png" alt=""></p>
<p>到此为止我们可以大概的了解到一个Servlet程序运行需要进行的步骤</p>
<h5 id="一般运行步骤"><a href="#一般运行步骤" class="headerlink" title="一般运行步骤"></a>一般运行步骤</h5><ul>
<li>导入Servlet需要依赖的其他库</li>
<li>编写servlet，编译生成相应的.class文件</li>
<li>servlet的部署默认情况下，Servlet 应用程序位于路径<code>&lt;Tomcat-installation-directory&gt;</code>/webapps/ROOT 下，且类文件放在<code>&lt;Tomcat-installation-directory&gt;</code>/webapps/ROOT/WEB-INF/classes 中。这时我们就可以根据这个把自己的servlet程序放到上诉位置，然后修改<code>&lt;Tomcat-installation-directory&gt;</code>/webapps/ROOT/WEB-INF/ 的 <strong>web.xml</strong>即可。web.xml编写的时候一定要注意把相应的配置写到<code>&lt;web-app&gt;...&lt;/web-app&gt;</code>标签内。</li>
<li>然后通过相应的映射就可以进行访问了</li>
</ul>
<h5 id="IDE运行步骤"><a href="#IDE运行步骤" class="headerlink" title="IDE运行步骤"></a>IDE运行步骤</h5><p>当然现在大多数人都是使用IDE直接进行Servlet的编写，通过IDE我们就不需要再去向classpath里面添加servlet的软件包了，我们可以直接在创建项目的时候将相应的包加载进来就可以了。但是我们发现似乎只是这样的话那么工作量其实并没有减少好多呀，还是要进行xml的配置，感觉依旧麻烦，其实我们可以通过注解的方式来替代xml的配置，具体看下面的代码。</p>
<p>ServletTest.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebInitParam;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet3.0 默认不在有web.xml</span></span><br><span class="line"><span class="comment"> * 3.0中采用<span class="doctag">@webServlet</span>注解的方式来配置一些相应的参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *WebServlet注解用来声明一个Servle。命名Servlet时，还可以暗示容器，是哪个URL调用这个Servlet</span></span><br><span class="line"><span class="comment"> *name属性是可选的，如果写的话，一般是该Servlet的名称</span></span><br><span class="line"><span class="comment"> *重要的是urlPatterns属性，他也是可选的但是一般都要有，在ServletTest中urlPatterns告诉容器，/Demo样式表示应该调用该servlet</span></span><br><span class="line"><span class="comment"> * initParams指定一组 Servlet 初始化参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@WebInitParam</span> 用来配置 initParams name为InitParameter名字，value为值，之间用特殊符号隔开，这里用逗号。</span></span><br><span class="line"><span class="comment"> * 这个就相当于在xml中写入：</span></span><br><span class="line"><span class="comment"> * &lt;servlet&gt;&lt;!-- 定义servlet--&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;servlet-name&gt;hello&lt;/servlet-name&gt;&lt;!-- 与servlet-mapping相对应--&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;servlet-class&gt;&lt;!-- 定义包.类名称--&gt;</span></span><br><span class="line"><span class="comment"> *         ServletTest&lt;!-- 我这个Servlet没有包所以直接写类名--&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;/servlet-class&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;init-param&gt;&lt;!-- 定义初始化参数--&gt;</span></span><br><span class="line"><span class="comment"> *       &lt;param-name&gt;admin&lt;/param-name&gt;&lt;!-- 表明初始化参数的名字--&gt;</span></span><br><span class="line"><span class="comment"> *       &lt;param-value&gt;yqh&lt;/param-value&gt;&lt;!-- 参数对应的值--&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;/init-param&gt;</span></span><br><span class="line"><span class="comment"> *      &lt;init-param&gt;</span></span><br><span class="line"><span class="comment"> *        &lt;param-name&gt;email&lt;/param-name&gt;</span></span><br><span class="line"><span class="comment"> *        &lt;param-value&gt;1290341092@qq.com&lt;/param-value&gt;</span></span><br><span class="line"><span class="comment"> *       &lt;/init-param&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;/servlet&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;servlet-mapping&gt;&lt;!-- 映射路径--&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;servlet-name&gt;hello&lt;/servlet-name&gt;&lt;!-- 与servlet相对应--&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;url-pattern&gt;/Demo&lt;/url-pattern&gt;&lt;!-- 页面的映射路径--&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;/servlet-mapping&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"ServletTest"</span>, urlPatterns = <span class="string">"/Demo"</span>,</span><br><span class="line">        initParams = &#123;<span class="meta">@WebInitParam</span>(name = <span class="string">"admin"</span>, value = <span class="string">"yqh"</span>),</span><br><span class="line">                <span class="meta">@WebInitParam</span>(name = <span class="string">"email"</span>, value = <span class="string">"1290341092@qq.com"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletTest</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig servletConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> servletConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servletConfig = servletConfig;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletConfig servletConfig = getServletConfig();</span><br><span class="line">        String admin = servletConfig.getInitParameter(<span class="string">"admin"</span>);</span><br><span class="line">        String email = servletConfig.getInitParameter(<span class="string">"email"</span>);</span><br><span class="line">        response.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        writer.print(<span class="string">"&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;"</span> + <span class="string">"admin"</span> + admin + <span class="string">"&lt;br&gt;Email"</span> + email + <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"555555555"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上写注解的形式就在功能上相当于了在xml文件写如下代码</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span><span class="comment">&lt;!-- 定义servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span><span class="comment">&lt;!-- 与servlet-mapping相对应--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span><span class="comment">&lt;!-- 定义包.类名称--&gt;</span></span><br><span class="line">        ServletTest<span class="comment">&lt;!-- 我这个Servlet没有包所以直接写类名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span><span class="comment">&lt;!-- 定义初始化参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span><span class="comment">&lt;!-- 表明初始化参数的名字--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>yqh<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span><span class="comment">&lt;!-- 参数对应的值--&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>email<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>1290341092@qq.com<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span><span class="comment">&lt;!-- 映射路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span><span class="comment">&lt;!-- 与servlet相对应--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Demo<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span><span class="comment">&lt;!-- 页面的映射路径--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当你在IDE中配置好了该项目的容器时，就可以直接运行这个项目，然后在浏览器中输入 “<a href="http://localhost:8080/Demo”就可以访问了。" target="_blank" rel="noopener">http://localhost:8080/Demo”就可以访问了。</a></p>
<p><img src="/2019/03/18/MVC/3.png" alt=""></p>
<h4 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h4><h5 id="什么是Servlet的生命周期呢？"><a href="#什么是Servlet的生命周期呢？" class="headerlink" title="什么是Servlet的生命周期呢？"></a>什么是Servlet的生命周期呢？</h5><p>​     <em>Servlet生命周期，即阐述Servlet从产生到毁灭的整个过程</em>。前面介绍Servlet接口的时候说过Servlet提供了三个生命周期方法 <em>初始化方法init(),处理客户请求的方法service(),终止方法destroy()。</em> 他们将在Servlet的生命周期中发挥自己作用。下面先看一个图解</p>
<p><img src="/2019/03/18/MVC/4.jpg" alt=""></p>
<p>图中展示的就是一个Servlet的生命周期的过程，生命周期包括<strong>加载程序</strong>，<strong>初始化</strong>，<strong>服务</strong>，<strong>销毁</strong>，<strong>卸载</strong>5个部分。</p>
<p>上面的各个生命周期都可以的Servlet中找到相对应的方法，如下表所示。</p>
<table>
<thead>
<tr>
<th style="text-align:center">No</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public void init() throws ServletException</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">Servlet初始化时候调用（非生命周期方法）</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public void init(ServletConfig servletConfig) throws ServletException</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">Servlet初始化时候调用，可以通过ServletConfig读取配置信息</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">Servlet服务，一般不会直接覆写此方法，而是使用doGet()或doPost()</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">public void destroy()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">Servlet销毁时使用</td>
</tr>
</tbody>
</table>
<h4 id="各个生命周期的作用"><a href="#各个生命周期的作用" class="headerlink" title="各个生命周期的作用"></a>各个生命周期的作用</h4><h5 id="1-加载Servlet"><a href="#1-加载Servlet" class="headerlink" title="1. 加载Servlet"></a>1. 加载Servlet</h5><p>  Web容器负责加载Servlet，当Web容器<strong>启动</strong>的时候或者是在<strong>第一次使用</strong>这个Servlet的时候，容器会负责创建Servlet实列，但是用户必须通过部署描述符指定Servlet的位置（Servlet所在的包.类名称）（也可以使用注解的方式），成功加载后，Web容器会通过反射的方式对Servlet进行实列化。</p>
<h5 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h5><p>当一个Servlet被实例化后，容器将调用init（）方法初始化这个对象，初始化的目的是为让Servlet对象在处理客户端请求前完成一些初始化的工作，如建立数据库的连接，读取资源文件信息等，如果初始化失败，这个Servlet将被直接卸载。</p>
<h5 id="3-处理服务"><a href="#3-处理服务" class="headerlink" title="3.处理服务"></a>3.处理服务</h5><p>当有请求提交的时候。Servlet将调用service()方法（常用的是doGet或者doPost()）进行处理，在service()方法中，Servlet可以通过ServletRequest接收客户的请求，也可以利用ServletResponse设置响应消息。</p>
<h5 id="4-销毁"><a href="#4-销毁" class="headerlink" title="4.销毁"></a>4.销毁</h5><p>当Web容器关闭或者检测到一个Servlet要从容器中删除的时候，会自动调用destroy()方法，以便使该实例释放掉所占用的资源</p>
<h5 id="5-卸载"><a href="#5-卸载" class="headerlink" title="5.卸载"></a>5.卸载</h5><p>当一个Servlet调用玩destroy()方法后，此实例将等待被垃圾收集器回收，如果需要再次使用此Servlet的时候，会重新调用init()方法初始化。</p>
<p>注：在正常情况下，Servlet只会被初始化一次，而处理服务会被调用多次，销毁也只会调用一次，但是yigeServlet长时间不使用的话，也会被容器自动销毁，而如果需要再次使用时会重新进行初始化的操作，记载特殊情况下初始化可能会进行多次，销毁也会被调用多次。</p>
<p>下面通过一个例子分析这个过程</p>
<h5 id="6-示例"><a href="#6-示例" class="headerlink" title="6.示例"></a>6.示例</h5><p>LifeCycleServlet.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*用来观察一个Servlet程序的生命周期的运行过程</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(name=<span class="string">"LifeCycleServlet"</span>,urlPatterns=<span class="string">"/life"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCycleServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig servletConfig;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当容器启动的时候或者第一次使用这个Servlet的时候会调用此方法进行初始化信息，重复请求时也只会调用一次（第一次）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>    <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span>  <span class="keyword">throws</span> ServletException</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servletConfig = servletConfig;</span><br><span class="line">        System.out.println(<span class="string">"Servlet----------&gt;初始化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 当客户端请求服务的时候会调用此方法，重复请求时重复调用此方法</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request, ServletResponse response)</span><span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Servlet----------&gt;调用服务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 当容器关闭的时候或者web应用程序从容器中删除的时候调用此方法</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Servlet----------&gt;销毁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是一个Servlet"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> servletConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2019/03/18/MVC/5.png" alt=""></p>
<p>由运行结果可以看出分成了3个部分</p>
<ul>
<li>标号为1的部分就是当我们第一次调用,在浏览器输入<code>http://localhost:8080/life</code>此Servlet输出的信息。因为我们使用了此Servlet，所以服务器会去查询是否有此Servlet的实列，由于这里是第一次使用，所以服务器肯定不会有此Servlet的实列，所以服务器就创建一个此<strong>Servlet的实列对象</strong>，然后调用该对象的<strong>init()</strong>方法进行初始化，所以这里可以看到第一句的  “Servlet————&gt;初始化”  这样的输出，然后由于我们调用了Servlet，即请求了他的服务所以下面输出了   “Servlet————&gt;调用服务”  这条语句，即调用了service()方法.</li>
<li>标号为2的部分则是在第一次通过 <code>http://localhost:8080/life</code> 请求Servlet后，再次请求了两次该Servlet，根据输出可以看出，这时只有服务的调用，则不会再次对Servlet进行初始化。</li>
<li>标号为3的部分则是我关闭了Web容器，此时之前创建的Servlet就会随着容器的关闭而被销毁，所以可以看到  “Servlet————&gt;销毁” 这条语句的输出，即此时调用了destroy()方法。</li>
</ul>
<font size="5" color="red"><strong>注</strong>：</font>在前面代码init()方法我们介绍过除第一次调用此Servlet的时候会调用此方法，还有一种就是在Web容器启动的时候自动为Servlet进行初始化，那么什么时候会出现第二种情况呢？其实在默认情况下，初始化方法是在第一次调用的时候使用，那么要想出现第二种情况就肯定少不了我们的配置文件了。所有我们可以通过配置<strong>web.xml</strong> 文件来完成，配置如下<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LifeCycleServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>LifeCycleServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span><span class="comment">&lt;!-- 自定加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  &lt;load-on-startup&gt;元素配置的数必须为正整数，数字越小，Servlet越优先创建。   --&gt;</span></span><br></pre></td></tr></table></figure><br><br>​        通过这种方法人们就可以在web容器启动的时候装载Servlet。<br><br>​        当然除了通过配置xml的方法还可以通过注解的方法，代码如下<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*用来观察一个Servlet程序的生命周期的运行过程,并配置自动加载</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">@WebServlet(name=<span class="string">"LifeCycleServlet"</span>,</span><br><span class="line">            urlPatterns=<span class="string">"/life"</span>,</span><br><span class="line">            loadOnStartup = <span class="number">1</span> <span class="comment">//配置了自动加载</span></span><br><span class="line">           )</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LifeCycleServlet</span> <span class="title">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">   ......................</span><br><span class="line">   ......................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>运行结果<br><br><img src="/2019/03/18/MVC/6.png" alt=""><br><br>将这个与上面的进行对比可以看出init()方法可以两种不同的情况下调用<br><br>​        <font color="red">用途：为web应用写一个InitServlet，这个Servlet配置为启动时装载，为整个web应用创建必要的数据库表和数据。</font>

<p>通过上面的过程可以可以总结出的运行过程</p>
<h4 id="Servlet的运行过程"><a href="#Servlet的运行过程" class="headerlink" title="Servlet的运行过程"></a>Servlet的运行过程</h4><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p>Servlet程序是由<strong>web服务器</strong>调用，web服务器收到<strong>客户端</strong>的Servlet访问<strong>请</strong>求后： </p>
<p>①web服务器<strong>首先检查</strong>是否<strong>已经装载并创建</strong>了该Servlet的<strong>实例对象</strong>。如果是，则直接执行第④步，否则，执行第②步。<br>②<strong>装载并创建</strong>该Servlet的一个<strong>实例对象</strong>。<br>③调用Servlet<strong>实例对象</strong>的<strong>init()方法</strong>。<br>④创建一个用于封装HTTP请求消息的<strong>HttpServletRequest</strong>对象和一个代表HTTP响应消息的<strong>HttpServletResponse</strong>对象，然后调用Servlet的<strong>service()方法</strong>并将请求和响应对象作为参数传递进去。</p>
<p> ⑤web应用程序被停止或重新启动之前，Servlet引擎将<strong>卸载Servlet</strong>，并在卸载之前调用Servlet的<strong>destroy()方法</strong>。 </p>
<p>destory()方法会在<strong>web容器移除servlet时</strong>执行，客户机<strong>第一次</strong>访问服务器时，服务器会<strong>创建</strong>servlet实例对象，它就<strong>永远驻留</strong>在<strong>内存</strong>里面了，等待客户机第二次访问，这时有一个用户访问完servlet之后，此servlet对象并不会被摧毁，destory()方法就不会被执行。 </p>
<p><strong>一道面试题：请说出servlet的生命周期</strong>。 </p>
<p>答：servlet对象是用户第一次访问时创建，对象创建之后就驻留在<strong>内存</strong>里面了，响应后续的请求。servlet对象一旦被创建，<strong>init()</strong>就会被执行，客户端的每次请求导致<strong>service()方法</strong>被执行，servlet对象被摧毁时(web服务器停止后或者web应用从服务器里删除时)，<strong>destory()方法</strong>就会被执行。</p>
<p>在Servlet的整个生命周期内，Servlet的init方法只被调用一次。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的service方法。<strong>对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象</strong>，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。 </p>
<h5 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h5><p>不知道你是否注意到了上面的④的过程提到了两个对象 HttpServletRequest对象和HttpServletResponse 这两个对象将会被传入到service()方法中，但是我们现在来看一下service的签名 <strong>service(ServletRequest request, ServletResponse response)</strong>  我们可以发现service()方法需要的参数并不是一致的，那么它们之间存在什么关系呢？前面我们提到过HttpServlet的时候有介绍过  <strong>HttpServletRequest 和 HttpServletResponse，这两个类分别是 ServletRequest 和 ServletResponse 的子类</strong>  ，下面我们先分别看一下官方对这四个类的描述，再来阐释为什么时是这样。</p>
<h4 id="运行过程的补充"><a href="#运行过程的补充" class="headerlink" title="运行过程的补充"></a>运行过程的补充</h4><h5 id="ServletRequest"><a href="#ServletRequest" class="headerlink" title="ServletRequest"></a>ServletRequest</h5><p>公共接口ServletRequest定义一个对象，以便向servlet提供客户机请求信息。servlet容器创建一ServletRequest对象，并将其作为参数传递给servlet的服务方法。ServletRequest对象提供包括参数名称和值、属性和输入流在内的数据。扩展ServletRequest的接口可以提供额外的特定于协议的数据(例如，HTTP数据由HttpServletRequest提供)。</p>
<h5 id="ServletResponse"><a href="#ServletResponse" class="headerlink" title="ServletResponse"></a>ServletResponse</h5><p>公共接口ServletResponse定义一个对象，以帮助servlet向客户机发送响应。servlet容器创建一ServletResponse对象，并将其作为参数传递给servlet的服务方法。要在MIME主体响应中发送二进制数据，请使用 getOutputStream()返回的ServletOutputStream。要发送字符数据，请使用getWriter()返回的PrintWriter对象。</p>
<h5 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h5><p>公共接口HttpServletRequest扩展了ServletRequest接口，为HTTP servlet提供请求信息。servlet容器创建一个HttpServletRequest对象，并将其作为参数传递给servlet的服务方法(doGet、doPost等)。</p>
<h5 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h5><p>公共接口HttpServletResponse 扩展了ServletResponse接口，以在发送响应时提供http特定的功能。例如，它有访问HTTP头文件和cookie的方法。servlet容器创建一个HttpServletResponse对象，并将其作为参数传递给servlet的服务方法(doGet、doPost等)。</p>
<p><strong>通过上面四个类的描述我们可以发现一个重要的东西 HTTP ，这个就涉及到了Servlet的处理协议的问题，<font color="red">从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</font>之前提到过   HttpServlet————&gt;GenericServlet————&gt;Servlet ，以上我们的所有的代码都是实现的javax.servlet.Servlet来展示的，而这个接口定义了所有Servlet必须实现的方法。所以上面才会出现创建HttpServletRequest对象和HttpServletResponse 这两个对象将会被传入到service()方法中,当然如果以后出现了其他的协议的时候传进的参数也就可能是XXXServletRequest对象和XXXServletResponse 这两个对象，但是不管是什么对象，它一定会是ServletRequest，ServletResponse的子类。了解这一点是很有必要的，因为有时候我们编写的Servlet是实现的<font color="red">javax.servlet.Servlet</font> 的时候，而我们又需要对cookie或者session进行操作的时候，一定要将service(ServletRequest request, ServletResponse response)的参数进行向下转型为HttpServletRequest 和 HttpServletResponse，因为，不管是cookie还是session都是属于http协议的范畴，如果不进行转型的话，你将不能通过相应的方法得到相应的数据 。</strong></p>
<font color="red"><strong>当然这个向下转型的应用其实用的最多的是在Filter中，通过doFilter()方法将参数向下转型过后对session进行判断</strong></font>



<p>通过以上的描述应该对一个普通的Servlet（javax.servlet.Servlet）有了一个很好的理解。下面我们来看一下GenericServlet这个类</p>
<h4 id="GenericServlet-1"><a href="#GenericServlet-1" class="headerlink" title="GenericServlet"></a>GenericServlet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>,<span class="title">ServletConfig</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//GenericServlet通过将ServletConfig赋给类级变量</span></span><br><span class="line">   <span class="keyword">private</span> trServletConfig servletConfig;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.servletConfig=servletConfig;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       自定义init()的原因是：如果子类要初始化必须覆盖父类的init() 而使它无效 这样</span></span><br><span class="line"><span class="comment">       this.servletConfig=servletConfig不起作用 ，此时servletConfig=null</span></span><br><span class="line"><span class="comment">       这样就会导致在其他方法中使用servletConfig进行一系列操作的代码发生空指针异常</span></span><br><span class="line"><span class="comment">       这样如果子类要初始化，可以直接覆盖不带参数的init()方法 </span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">this</span>.init();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//自定义的init()方法，可以由子类覆盖  </span></span><br><span class="line">   <span class="comment">//init()不是生命周期方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//实现service()空方法，并且声明为抽象方法，强制子类必须实现service()方法 </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request,ServletResponse response)</span> </span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> ServletException,java.io.IOException</span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//实现空的destroy方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果试着去实现一个普通的Servlet，你会发现其实是一件麻烦的事情，因为你不得不去实现他所有的abstract方法，而很多的时候我们只需要去实现他的service()方法，并且这样的一个servlet而干的事情是非常的有限的，要实现更多的功能，就不得不自己每次去编写，但其实很多的功能在大多数的情况下是通用的，所以就有了GenericServlet。</p>
<p>公共抽象类GenericServlet  extends java.lang.Object implements Servlet, ServletConfig, java.io.Serializable。</p>
<p>该类定义一个普通的、依赖于协议的servlet，如果要写一个用于Web的HTTP servlet，扩展HpptServlet。一个servlet可以直接扩展GenericServlet类，然而扩展一个指定协议的子类（如HttpServlet）显得更为普遍。GenericServlet类使编写servlets变得更容易。它提供了一般版本的生命周期方法：inin()，destroy()和来自ServletConfig接口的方法。GenericServlet类也实现了log()方法，这是一个在ServletContext类中定义的方法。</p>
<p>总之，GenericServlet正如他的名字通用Servlet一样，它可以解决大多数的情形，但是我们一般不会用它，而是选择HttpServlet,因为Servlet只用来响应居于HTTP协议的Web服务器，那么它保留的意义在哪？这是为了让以后出现其他协议的时候可以更好的让Servlet对这个协议进行扩展的。</p>
<font size="4" color="red">注：在GenericServlet中有两个init方法(),一个为没带参数（非生命周期方法），一个为带参数（生命周期方法）,在我们自定义Servlet继承于它的时候，尽量不要去覆写生命周期init()方法。而是覆写非生命周期init()方法进行初始化。因为覆盖父类的生命周期方法init() 而使它无效 这样<br>       this.servletConfig=servletConfig不起作用 ，此时servletConfig=null<br>       这样就会导致在其他方法中使用servletConfig进行一系列操作的代码发生空指针异常</font>

<p>详细介绍：<a href="http://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/GenericServlet.html" target="_blank" rel="noopener">GenericServlet</a></p>
<h4 id="HttpServlet-1"><a href="#HttpServlet-1" class="headerlink" title="HttpServlet"></a>HttpServlet</h4><p>HttpServlet extends GenericServlet implements java.io.Serializable </p>
<p>httpServlet 提供要子类化的抽象类，以创建适合于Web站点的HTTP servlet。HttpServlet的子类必须覆盖至少一个方法，通常是以下方法之一:</p>
<ul>
<li>doGet，如果servlet支持HTTP GET请求</li>
<li>doPost，用于HTTP POST请求</li>
<li>doPut，用于HTTP PUT请求</li>
<li>doDelete，用于HTTP删除请求</li>
<li>init and destroy，以管理servlet生命周期中保存的资源</li>
<li>getServletInfo, servlet使用它来提供关于自身的信息</li>
</ul>
<p>几乎没有理由重写service方法。service通过将标准HTTP请求分派给每种HTTP请求类型的处理程序方法(上面列出的doXXX方法)来处理标准HTTP请求。同样，几乎没有理由重写doOptions和doTrace方法。<font color="red">如果重写了service方法，则对应的doXXXX方法就不再起作用，而是直接调用service方法进行处理</font> 。从实际开发来看，doGet()和doPost()两个方法的使用几率最高，所以一般主要覆写这两个方法。</p>
<h3 id="Servlet的应用"><a href="#Servlet的应用" class="headerlink" title="Servlet的应用"></a>Servlet的应用</h3><h4 id="取得初始化配置信息"><a href="#取得初始化配置信息" class="headerlink" title="取得初始化配置信息"></a>取得初始化配置信息</h4><p>通过前面的生面周期的介绍，我们可以看到一个Init(ServletConfig config)方法，通过此方法我们可以获得一个ervletConfig 实例对象，我们可以通过这个对象来获取到一些东西（具体查阅此接口的方法），这里我们通过他的</p>
<p>getInitParameter（）方法，来获得初始化配置信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebInitParam;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来取得配置的初始化信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@method</span> getInitParameter </span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"InitParamServlet"</span>, urlPatterns = <span class="string">"/param"</span>,</span><br><span class="line">        initParams = &#123;<span class="meta">@WebInitParam</span>(name = <span class="string">"name"</span>, value = <span class="string">"yqh"</span>),</span><br><span class="line">                <span class="meta">@WebInitParam</span>(name = <span class="string">"phone"</span>, value = <span class="string">"13145201314"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">)<span class="comment">//通过注解的形式来代替xml文件的配置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitParamServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">private</span> String phone=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>    <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException</span>&#123;</span><br><span class="line">        name = config.getInitParameter(<span class="string">"name"</span>);</span><br><span class="line">        phone = config.getInitParameter(<span class="string">"phone"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span>  ServletException, IOException</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"doGet获取初始化参数 ：name ："</span>+name+<span class="string">" phone : "</span>+phone );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span>  ServletException, IOException</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"doPost获取初始化参数 ：name ："</span>+name+<span class="string">" phone : "</span>+phone );</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在浏览器输入URL请求此Servlet我们可以看到这样的输出</p>
<p><strong>doGet获取初始化参数 ：name ：yqh phone : 13145201314</strong></p>
<p>说明通过ServletConfig对象的getInitParameter方法的确获取到了他的初始话配置信息。这里可以看到是调用的doGet方法，这是因为在浏览器输入URL的方式默认为get请求。</p>
<p>上面的getInitParameter只能根据初始化参数的名字来获取相应的值，如果有多个参数的时候还用此方法，将会使得代码变得臃肿，所以这时候就可以通过另外一个方法 getInitParameterNames()取得全部初始化参数名称。然后通过getInitParameter获得所有的值。</p>
<p>代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebInitParam;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来取得配置的初始化信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@method</span> getInitParameterNames</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"InitParamServlet"</span>, urlPatterns = <span class="string">"/params"</span>,</span><br><span class="line">        initParams = &#123;<span class="meta">@WebInitParam</span>(name = <span class="string">"name"</span>, value = <span class="string">"yqh"</span>),</span><br><span class="line">                <span class="meta">@WebInitParam</span>(name = <span class="string">"phone"</span>, value = <span class="string">"13145201314"</span>),</span><br><span class="line">                <span class="meta">@WebInitParam</span>(name = <span class="string">"class"</span>, value = <span class="string">"03011703"</span>),</span><br><span class="line">                <span class="meta">@WebInitParam</span>(name = <span class="string">"sex"</span>, value = <span class="string">"男"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitParameterNamesServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Enumeration enums = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig config = <span class="keyword">null</span>;<span class="comment">//用来接收config对象,不然后面获取不到每一个参数的具体值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">        enums = config.getInitParameterNames();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">            ServletException, IOException </span>&#123;</span><br><span class="line">        String param = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (enums.hasMoreElements()) &#123;</span><br><span class="line">            param = (String) enums.nextElement();</span><br><span class="line">            System.out.println(<span class="string">"doGet获取的参数："</span> + param + <span class="string">" : "</span> + config.getInitParameter(param));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">            ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><strong>doGet获取的参数：phone : 13145201314</strong><br><strong>doGet获取的参数：sex : 男</strong><br><strong>doGet获取的参数：name : yqh</strong><br><strong>doGet获取的参数：class : 03011703</strong></p>
<p>以上代码就是通过getInitParameterNames获取全部配置参数的演示，需要注意的是此方法返回的是Enumeration的数据，然后通过nextElement()返回的是一个Object对象。然后再通过ServletConfig对象调用getInitParameter()获取它的具体的值时要将它转换成String后再作为参数。</p>
<p>还有需要注意的是，我们一个要定义一个ServletConfig对象，然后在init（）方法中将自定义的ServletConfig对象用来接收由Web容器创立的ServletConfig对象。不然在调用getInitParameter()的时候会出现空指针异常。</p>
<h4 id="取得其他的内置对象"><a href="#取得其他的内置对象" class="headerlink" title="取得其他的内置对象"></a>取得其他的内置对象</h4><p>在上面介绍过可以通过Servlet获取到config对象，实际上通过Servlet程序也可以取得session以及application的内置对象。</p>
<p>在Servlet程序中要想获得一个session对象，则可以通过HttpServletRequest接口完成。 取得HttpSession的接口实例：</p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public HttpSession getSession（）</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">返回当前的session</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public HttpSession getSession（boolean create）</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">返回当前的session,*如果没有则创建一个新的session对象返回</td>
</tr>
</tbody>
</table>
<p>看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过HttpServletSession获得session</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"GetHttpSessionServlet"</span>,urlPatterns = <span class="string">"/session"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetHttpSessionServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sesssion的获取"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">            ServletException, IOException </span>&#123;</span><br><span class="line">        HttpSession session = request.getSession();<span class="comment">//HttpServletRequest接口调用getSession可以返回一个HttpSession</span></span><br><span class="line">        session.setAttribute(<span class="string">"name"</span>,<span class="string">"yqh"</span>);</span><br><span class="line">        System.out.println(<span class="string">"获取存到session的name："</span>+session.getAttribute(<span class="string">"name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过实现了HttpServlet的类直接通过HttpServletSession对象可以返回Httpsession对象，十分方便，下面看另外一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.GenericServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过ServletRequest获得HttpSession</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"GetHttpSessionServletDemo"</span>,urlPatterns = <span class="string">"/resession"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReGetHttpSessionServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span>&#123;</span><br><span class="line"></span><br><span class="line">        HttpServletRequest req=(HttpServletRequest)request;<span class="comment">//将ServletRequest对象转换成HttpServletRequest</span></span><br><span class="line">        HttpServletResponse rep=(HttpServletResponse)response;<span class="comment">//将ServletResponse对象转换成HttpServletResponse</span></span><br><span class="line">        HttpSession session=req.getSession();</span><br><span class="line"></span><br><span class="line">        session.setAttribute(<span class="string">"name"</span>, <span class="string">"yqh"</span>);</span><br><span class="line">        System.out.println(<span class="string">"通过将ServletRequest向下转型获取存到session的name："</span> + session.getAttribute(<span class="string">"name"</span>));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序同样获取到了session，但是可以看到这段代码与上面代码的不同之处就在于这两句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest req=(HttpServletRequest)request</span><br><span class="line">HttpServletResponse rep=(HttpServletResponse)response;</span><br></pre></td></tr></table></figure>
<p>在这里我们对service方法的参数进行了向下转型的操作，然后通过向下转型对象调用getSession方法。从而获得HttpSession对象。</p>
<p><font color="red" size="5">注: </font>在获取session对象的时候一定要注意你的Servlet实现的是HttpServlet，还是SerVlet和GenericServlet。如果是前者，那么他相应的服务方法的参数就是HttpServletRequest和HttpServletResponse,此时可以直接调用getSession方法取得session。如果是后者那么他的service方法的参数就是ServletRequest和ServletResponse，此时如果需要获得session，则一定要把Servlet对象向下转型为HttpServletRequest对象，此时才能调用getsession()获取到session。</p>
<h4 id="取得ServletContext实例"><a href="#取得ServletContext实例" class="headerlink" title="取得ServletContext实例"></a>取得ServletContext实例</h4><p>ServletContext官方叫servlet上下文。服务器启动时会为每一个工程创建一个对象，这个对象就是ServletContext对象。这个对象全局唯一，而且工程内部的所有servlet都共享这个对象。所以叫全局应用程序共享对象。如果要在一个Servlet中使用此对象，直接通过GenericServlet类提供的方法即可(<strong>HttpServlet继承了GenericServlet类的所有方法</strong>，只是自己根据请求方式的不同重写了service方法())。</p>
<table>
<thead>
<tr>
<th style="text-align:center">N0.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public   ServletContext   getServletContext()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得ServletContext对象</td>
</tr>
</tbody>
</table>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取ServletContext对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@method</span> 通过重GenericServlet继承来的getServletContext()</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"GetServletContextServlet"</span>, urlPatterns = <span class="string">"/application"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetServletContextServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 注释一：覆写了生命周期init()方法，注意覆写非生命周期init()方法的区别</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException</span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.init(config);<span class="comment">//注释二：调用父类的生命周期方法init(),初始化ServletConfig对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext app = getServletContext();</span><br><span class="line">        System.out.println(<span class="string">"真实路径 ： "</span> + app.getRealPath(<span class="string">"/6666666"</span>));</span><br><span class="line">        <span class="comment">//getRealPath（）的参数代表在真实路径后面添加的字符串内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过直接调用父类的getServletContext()方法就可以获取到ServletContext对象，<strong>特别注意</strong> 方面注释一二的地方。</p>
<p>思考一下为什么？思考前我们先看一下getServletContext()方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getServletConfig().getServletContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.config;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到一个东西：ServletConfig实列对象 config 。相信看到这里你肯定已经明白了为什么。因为生命周期init方法，除了初始化，还干了一件特别重要的事情，那就是获取服务器创建的config对象将它赋值给我们自己创建的config对象。如果将生命周期方法init（）覆写了，而又没有对自己创建的config对象赋初值，那么它默认为null，也就会导致在后面所有的通过config调用的方法报空指针异常。</p>
<p>所以在我们写Servlet时不要去覆写生命周期方法init()方法，如果非要去覆盖，那么一定要调用父类的生命周期init（）方法对config对象进行接收。</p>
<h4 id="Servlet跳转"><a href="#Servlet跳转" class="headerlink" title="Servlet跳转"></a>Servlet跳转</h4><p>从一个JSP或者HTML页面可以通过表单或超链接跳转到Servlet，那么从Servlet也可以跳转到其他的Servlet，JSP或其他页面。而跳转又分为客户端跳转（重定向）和服务器端跳转（分发）。</p>
<h5 id="客户端跳转"><a href="#客户端跳转" class="headerlink" title="客户端跳转"></a>客户端跳转</h5><p>在Servlet中如果要想进行客户端跳转，直接使用HttpServletResponse接口的sendRedirect()方法就可以了，需要注意的是，此跳转只能传递session及application范围的属性，而无法传递request范围的属性。</p>
<p>代码示例：</p>
<p>ClientRedirectServlet.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(name=<span class="string">"ClientRedirectServlet"</span>,value = <span class="string">"/send"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientRedirectServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>    <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException</span>&#123;</span><br><span class="line">       request.getSession().setAttribute(<span class="string">"session"</span>,<span class="string">"这是一个客户端跳转呀传递的session"</span>);</span><br><span class="line">       request.setAttribute(<span class="string">"request"</span>,<span class="string">"这是一个客户端跳转呀传递的request"</span>);</span><br><span class="line">       getServletContext().setAttribute(<span class="string">"application"</span>,<span class="string">"这是一个客户端跳转呀传递的application"</span>);</span><br><span class="line">       response.sendRedirect(<span class="string">"Revice_info.jsp"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Revice_info.jsp</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: yqh</span><br><span class="line">  Date: <span class="number">2019</span>/<span class="number">3</span>/<span class="number">23</span></span><br><span class="line">  Time: <span class="number">17</span>:<span class="number">10</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;接收客户端跳转传来的信息&lt;/title&gt;</span><br><span class="line">    &lt;% request.setCharacterEncoding(<span class="string">"GBK"</span>);%&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;session属性：&lt;%=session.getAttribute("session")%&gt;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;request属性：&lt;%=request.getAttribute("request")%&gt;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;application属性：&lt;%=application.getAttribute("application")%&gt;&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是jsp文件与Servlet的位置关系，如果jsp文件不是在web根目录下面的话，servlet的sendRedirect（）参数要做相应改变。</p>
<p>启动web容器后，我们在浏览器输入localhost:8080/send后的结果如下。</p>
<p><img src="/2019/03/18/MVC/7.png" alt=""></p>
<p>这里需要注意的就是浏览器的URL,我们可以很显然的看见URL是变化了的，因为是客户端跳转。。。。然后还有就是JSP页面的输出关于request属性的值为null,这很好的说明了之前所说的客户端的跳转范围，request属性范围的内容无法在客户端跳转中接收到，因为request属性范围只有在服务器端跳转中才可以使用。</p>
<h5 id="服务器跳转"><a href="#服务器跳转" class="headerlink" title="服务器跳转"></a>服务器跳转</h5><p>在Servlet中没有像JSP中的<code>&lt;jsp:fowad&gt;</code>指令，所以要想执行服务器端跳转，就必须依靠RequestDispatcher接口来完成，此接口提供了下表所示的两种方法。</p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public void forward(ServletRequest request,ServletResponse response) throws ServletException，IOException</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">页面跳转</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public void include(ServletRequest request,ServletResponse response) throws ServletException，IOException</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">页面包含</td>
</tr>
</tbody>
</table>
<p>使用RequestDispatcher接口的forward()方法即可完成跳转功能的实现，但是如果要使用此接口还需要使用HttpRequest接口提供的如下表的方法进行初始化。</p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public RequestDispatcher getRequestDispatcher(String path)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得RequestDispatcher接口的实列</td>
</tr>
</tbody>
</table>
<p>下面通过具体的代码来看以下这个的实现</p>
<p>ServerRedirectServlet.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.RequestDispatcher;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"ServerRedircetServlet"</span>,value = <span class="string">"/foward"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerRedircetServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>    <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        request.getSession().setAttribute(<span class="string">"session"</span>,<span class="string">"这是一个服务器跳转呀传递的session"</span>);</span><br><span class="line">        request.setAttribute(<span class="string">"request"</span>,<span class="string">"这是一个服务器跳转呀传递的request"</span>);</span><br><span class="line">        getServletContext().setAttribute(<span class="string">"application"</span>,<span class="string">"这是一个服务器跳转呀传递的application"</span>);</span><br><span class="line">        RequestDispatcher rq=request.getRequestDispatcher(<span class="string">"Foward_info.jsp"</span>);</span><br><span class="line">        rq.forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Foward_info.jsp</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: yqh</span><br><span class="line">  Date: <span class="number">2019</span>/<span class="number">3</span>/<span class="number">23</span></span><br><span class="line">  Time: <span class="number">17</span>:<span class="number">51</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;接收服务器端跳转的内容&lt;/title&gt;</span><br><span class="line">    &lt;% request.setCharacterEncoding(<span class="string">"GBK"</span>);%&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;session属性：&lt;%=session.getAttribute("session")%&gt;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;request属性：&lt;%=request.getAttribute("request")%&gt;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;application属性：&lt;%=application.getAttribute("application")%&gt;&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>启动web容器后，我们在浏览器输入localhost:8080/foward后的结果如下。</p>
<p><img src="/2019/03/18/MVC/8.png" alt=""></p>
<p>通过运行结果可以看到URL并没有变化，但是输出的内容变成了JSP页面的内容，与此同时接收到了request属性的内容。</p>
<p>以上就是通过Servlet实现跳转的两种方式。</p>
<h2 id="进阶Servlet"><a href="#进阶Servlet" class="headerlink" title="进阶Servlet"></a>进阶Servlet</h2><p>JSP能完成的功能都可以用Servlet来完成，但是Servlet具备的很多功能是JSP所不具备的,从使用上来看Servlet是可以分为简单Servlet（之前所讲解的都属于简单Servlet），过滤Servlet（过滤器）和监听Servlet（监听器）3种。JSP所能完成的也只是简单的Servlet的功能，下面看一下过滤器的使用。</p>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><h4 id="Filter的基本概念"><a href="#Filter的基本概念" class="headerlink" title="Filter的基本概念"></a>Filter的基本概念</h4><p>Filter是在Servlet2.3之后添加的新功能，当需要限制用户访问某些资源或者在处理请求的时候提前处理某些资源的时候，即可使用过滤器来完成。</p>
<p>过滤器是以一种组件的形式绑定到Web应用程序当中的，与其他的Web应用组件不同的是，过滤器是采用 “ 链 ” 的方式进行处理的，如下图所示  </p>
<p><img src="/2019/03/18/MVC/9.png" alt=""></p>
<p>在没有过滤器之前，客户端都是直接请求Web资源的，但是一旦加入了了过滤器，所有的请求都会先交给过滤器来处理，然后再访问相应的Web资源，这样就可以达到对某些资源的限制。</p>
<h4 id="Filter如何实现拦截"><a href="#Filter如何实现拦截" class="headerlink" title="Filter如何实现拦截"></a>Filter如何实现拦截</h4><p>要想了解到Filter是如何实现拦截的那么首先应该去看一下他的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig var1)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest var1, ServletResponse var2, FilterChain var3)</span> <span class="keyword">throws</span> IOException, ServletException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上Filter的源码我们可以看到他只有三个方法。很显然init()和destroy()是生命周期方法，那么就可以知道Filter是通过doFilter()方法来实现拦截的。</p>
<h5 id="具体解释："><a href="#具体解释：" class="headerlink" title="具体解释："></a>具体解释：</h5><ul>
<li>当客户端发生请求后，在HttpServletRequest 到达Servlet 之前，过滤器拦截客户的HttpServletRequest 。 </li>
<li>根据需要检查HttpServletRequest ，也可以修改HttpServletRequest 头和数据。 </li>
<li>在过滤器中调用doFilter方法，对请求放行。请求到达Servlet后，对请求进行处理并产生HttpServletResponse发送给客户端。</li>
<li>在HttpServletResponse 到达客户端之前，过滤器拦截HttpServletResponse 。 </li>
<li>根据需要检查HttpServletResponse ，可以修改HttpServletResponse 头和数据。</li>
<li>最后，HttpServletResponse到达客户端。</li>
</ul>
<p>当我们编写好Filter后，并配置对哪个web资源进行拦截以后（在web.xml文件中配置或者使用注解的方式），Web服务器每次在调用Web资源的service方法之前，都会先调用一下Filter的doFilter方法，因此在该方法内编写代码可以达到如下目的：</p>
<ul>
<li>调用目标资源之前，让一段代码执行</li>
<li>觉得是否调用目标资源（即是否让用户访问Web资源）</li>
<li>调用目标资源之后让一段代码执行。</li>
</ul>
<p>web服务器在调用doFilter方法时，会传递一个filterChain对象进来，filterChain对象是filter接口中最重要的一个对 象，它也提供了一个doFilter方法，开发人员可以根据需求决定是否调用此方法，调用该方法，则web服务器就会调用web资源的service方 法，即web资源就会被访问，否则web资源不会被访问。</p>
<h4 id="Filter开发步骤"><a href="#Filter开发步骤" class="headerlink" title="Filter开发步骤"></a>Filter开发步骤</h4><p>了解了Filter的拦截原理过后，就可以自己动手写一个Filter了</p>
<p>Filter开发分为二个步骤：</p>
<ol>
<li>编写java类实现Filter接口，并实现其doFilter方法。</li>
<li>在 web.xml 文件中使用<code>&lt;filter&gt;</code>和<code>&lt;filter-mapping&gt;</code>元素对编写的filter类进行注册，并设置它所能拦截的资源。</li>
</ol>
<p>示例如下</p>
<h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><p>FilterTest.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编写一个Filter用来拦截访问</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterTest</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;<span class="comment">//初始化过滤器</span></span><br><span class="line">        System.out.println(<span class="string">"初始化一个过滤器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;<span class="comment">//执行过滤</span></span><br><span class="line">        System.out.println(<span class="string">" filterChain调用doFilter之前"</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest ,servletResponse);<span class="comment">//将请求继续传递</span></span><br><span class="line">        System.out.println(<span class="string">" filterChain调用doFilter之后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;<span class="comment">//销毁过滤</span></span><br><span class="line">        System.out.println(<span class="string">"过滤器销毁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><p>现在可以看到已经编写好了一个Filter，但是由于我们还没有对它进行配置，所以这个Filter是不起任何作用的，下面我们在web.xml文件进行配置 （当然也可以用注解的形式直接在Filter上进行配置）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span><span class="comment">&lt;!-- 注册filter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filtertest<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span><span class="comment">&lt;!-- filter的名字与filter-mapping相对应 不能为空--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span><span class="comment">&lt;!--元素用于指定过滤器的完整的限定类名。 --&gt;</span></span><br><span class="line">	FilterTest</span><br><span class="line">	<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 也可以在这个地方配置初始化参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span> <span class="comment">&lt;!--映射filter--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filtertest<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用于设置filter的注册名称。该值必须是在&lt;filter&gt;元素中声明过的过滤器的名字--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/foward<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置 filter 所拦截的请求路径(过滤器关联的URL样式)                   --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 除了通过url方式拦截之外，还可以配置servlet的拦截                     --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;servlet-name&gt;&lt;/servlet-name&gt; 指定过滤器所拦截的Servlet名称       --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 还可以用&lt;dispatcher&gt;指定过滤器所拦截的资源被 Servlet                --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 容器调用的方式可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST --&gt;</span></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过         --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。 --&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 器将被调用。除此之外，该过滤器不会被调用。                                    --&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过   --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 滤器将被调用，除此之外，该过滤器不会被调用。                                  --&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外， --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 过滤器不会被调用。                                                        --&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果是写注解的话就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(filterName=<span class="string">"filtertest"</span>,urlPatterns=<span class="string">"/foward"</span>)</span><br></pre></td></tr></table></figure>
<p>通过以上两步过后，当我们在浏览器输入要拦截的URL过后，就会调用该过滤器。后台的输出信息如下</p>
<p><img src="/2019/03/18/MVC/10.png" alt=""></p>
<p>根据输出我们可以看到过滤器中的初始化方法不用我们配置自动加载，它也会在Web容器启动的时候自动调用。</p>
<p>后面的输出可以看到doFilter会调用两次，一次是在FilterChain操作之前，一次是FilterChain操作之后。</p>
<p>（<font color="red">即请求到达服务器之前以及响应返回客户端之前</font>)</p>
<h4 id="Filter链"><a href="#Filter链" class="headerlink" title="Filter链"></a>Filter链</h4><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>在一个Web应用中，可以开发多个Filter，这些Filter经过配置就可以变成一个Filter链。</p>
<p>示例如下</p>
<p>FilterFirst.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*跟FilterSecond组合使用形成Filter链</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterFirst</span>  <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;<span class="comment">//初始化过滤器</span></span><br><span class="line">        System.out.println(<span class="string">"初始化一个过滤器-----FilterFirst"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;<span class="comment">//执行过滤</span></span><br><span class="line">        System.out.println(<span class="string">" filterChain调用doFilter之前-----FilterFirst"</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest ,servletResponse);<span class="comment">//将请求继续传递</span></span><br><span class="line">        System.out.println(<span class="string">" filterChain调用doFilter之后-----FilterFirst"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;<span class="comment">//销毁过滤</span></span><br><span class="line">        System.out.println(<span class="string">"过滤器销毁-----FilterFirst"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FilterSecond.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *跟FilterFirst组合使用形成Filter链</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterSecond</span>  <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;<span class="comment">//初始化过滤器</span></span><br><span class="line">        System.out.println(<span class="string">"初始化一个过滤器-----FilterFSecond"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;<span class="comment">//执行过滤</span></span><br><span class="line">        System.out.println(<span class="string">" filterChain调用doFilter之前-----FilterFSecond"</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest ,servletResponse);<span class="comment">//将请求继续传递</span></span><br><span class="line">        System.out.println(<span class="string">" filterChain调用doFilter之后-----FilterFSecond"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;<span class="comment">//销毁过滤</span></span><br><span class="line">        System.out.println(<span class="string">"过滤器销毁-----FilterFSecond"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>web.xml的配置如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterfirst<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">	FilterFirst</span><br><span class="line">	<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterfirst<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/foward<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filtersecond<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">	FilterSecond</span><br><span class="line">	<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filtersecond<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/foward<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在配置时,配置Filter的顺序就是该过滤链的执行顺序，这里需要注意的是两个Filter的<code>&lt;url-pattern&gt;</code>的标签内必须是同一个URL，这样这两个Filter才算组成了一个Filter链，否则他们将没多大关系。</p>
<p>通过如此配置之后，运行结果如下。</p>
<p><img src="/2019/03/18/MVC/11.png" alt=""></p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p> 从上面可以看出过滤链的初始化顺序<font color="red">不是按照web.xml文件对应的声明顺序进行的。这里的初始化顺序是根据<code>&lt;filter-name&gt;</code>的长度来决定的，谁的<code>&lt;filter-name&gt;</code>长，谁就先初始化。然后一样长的时候就开始比较<code>&lt;filter-name&gt;</code>的字母顺序，字母越靠前越先执行，有相同的就延后比较下一个字母。</font>（我也不是很明白为什么要这样设计来决定他的初始化顺序）这个需要特别的注意一下，网上的博客现在大多数说的都是根据注册顺序来声明的。</p>
<p>然后虽然初始化顺序与声明顺序无关，但是他的执行顺序却是跟初始化顺序一样的，即先初始化先执行。但是需要注意的是由于他是一个链式，所以可以看到 它的doFilter的执行，先会把所有的到达服务器前的请求依次过滤，然后再将服务器返回客户端的响应依次过滤返回。整个过程就很像一个函数的递归调用一样，详情如下图：</p>
<p><img src="/2019/03/18/MVC/12.png" alt=""></p>
<h4 id="Filter的生命周期"><a href="#Filter的生命周期" class="headerlink" title="Filter的生命周期"></a>Filter的生命周期</h4><p>Filter与Servlet一样也具有自己的生命周期，之前看Filter的源码的时候知道他有三个方法。</p>
<ul>
<li>init()方法：初始化参数，在创建Filter的时候（Web容器启动的时候）自动调用，当我们需要设置初始化参数的时候，可以写到该方法中。</li>
<li>doFilter()方法：拦截到要执行的请求的时候，doFilter就会执行，这里写我们对请求和响应的预处理。</li>
<li>destroy()方法：在销毁Filter时自动调用。</li>
</ul>
<p>很显然它的生命周期方法是init()方法和destory()方法。Filter的创建和销毁由web服务器控制。</p>
<ul>
<li>服务器启动的时候，web容器创建Filter的实列对象，并调用init()方法，完成对象的初始化功能。Filter对象只会创建一次，init()方法也只会执行一次。</li>
<li>拦截到请求的时候执行doFilter()方法，可以执行多次。</li>
<li>服务器关闭的时候，web服务器销毁Filter的实列对象。</li>
</ul>
<p>一个Filter的完整的生命周期就是如此。</p>
<h4 id="FilterConfig"><a href="#FilterConfig" class="headerlink" title="FilterConfig"></a>FilterConfig</h4><p>在生命周期的介绍中提到了init()方法可以初始化参数，那么初始参数的话肯定需要一个对象。我们看一下init方法的签名<code>init(FilterConfig var1)</code>可以看到它有一个FilterConfig类型的对象，这个对象有什么用呢？在前面介绍Servlet的时候，它的init()方法由ServletConfig,我们可以通过此参数我们可以获得一些该Servlet在web.xml的配置信息以及Servlet 容器的一些信息。同理FilterConfig对象也是用来获取一些Filter的配置信息和Servlet 容器的一些信息。</p>
<p>FilterConfig接口定义的各个方法：</p>
<ul>
<li>getFilterName 方法，返回 <code>&lt;filter-name&gt;</code>元素的设置值。</li>
<li>getServletContext 方法，返回 FilterConfig 对象中所包装的 ServletContext 对象的<strong>引用</strong>。</li>
<li>getInitParameter 方法，用于返回在 web.xml 文件中为 Filter 所设置的某个名称的初始化的参数值。</li>
<li>getInitParameterNames 方法，返回一个 Enumeration 集合对象。</li>
</ul>
<h4 id="Filter的应用"><a href="#Filter的应用" class="headerlink" title="Filter的应用"></a>Filter的应用</h4><p>Filter在实际的Web开发中发挥着巨大的用处，下面我们通过一些具体的代码来看看它可以干什么</p>
<h5 id="统一全站的字符编码"><a href="#统一全站的字符编码" class="headerlink" title="统一全站的字符编码"></a>统一全站的字符编码</h5><p>学习jsp的时候如果需要统一编码的话，需要在每一个jsp的页面加入相应打代码，这样就会照成大量的代码重复。于是我们我就可以通过一个Filter来解决这种问题，通过配置参数charset来指明使用哪一种字符编码，以处理乱码问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用来统一全站编码的Filter</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterEncondingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FilterConfig filterConfig = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String defaultCharset = <span class="string">"UTF-8"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">      filterConfig=config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;<span class="comment">//执行过滤</span></span><br><span class="line">        HttpServletRequest request =(HttpServletRequest)servletRequest;</span><br><span class="line">        HttpServletResponse response=(HttpServletResponse)servletResponse;</span><br><span class="line"></span><br><span class="line">        String charset=filterConfig.getInitParameter(<span class="string">"charset"</span>);</span><br><span class="line">        <span class="keyword">if</span> (charset==<span class="keyword">null</span>)&#123;</span><br><span class="line">            charset=defaultCharset;</span><br><span class="line">        &#125;</span><br><span class="line">        request.setCharacterEncoding(charset);</span><br><span class="line">        response.setCharacterEncoding(charset);</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(request, response);<span class="comment">//将请求继续传递</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="登录验证"><a href="#登录验证" class="headerlink" title="登录验证"></a>登录验证</h5><p>登陆验证在Web开发中是必不可少的一个环节，最早用样是在每个页面进行session的判断，于是也造成了大量的代码重复，而用过滤器来实现这些操作这可以避免这种重复的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *用于登录验证</span></span><br><span class="line"><span class="comment"> * 其中userid表示登录过后存入session的属性，login.jsp表示登录页面</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;<span class="comment">//执行过滤</span></span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse) servletResponse;</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        <span class="keyword">if</span> (session.getAttribute(<span class="string">"userid"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            filterChain.doFilter(request, response);<span class="comment">//将请求继续传递</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            request.getRequestDispatcher(<span class="string">"login.jsp"</span>).forward(request,response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Filter不止可以做上面的事情，事实上只要在开发中有需要自动完成的操作的时候，都可以通过Filter来处理。</p>
<h3 id="XXXListener"><a href="#XXXListener" class="headerlink" title="XXXListener"></a>XXXListener</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>上面介绍了第二种Servlet（Filter），现在介绍第三种Servlet，监听Servlet，它的主要功能是负责监听Web的各种操作，当相关的事件触发后将产生事件，并对此事件进行处理，在Web中可以对applicatin,session和request3种操作进行监听。事件源和监听器绑定的过程：通过配置web.xml来完成。</p>
<p>Servlet中提供了8个监听器，可以将它们分成3类。</p>
<p>一类：监听域对象的创建和销毁的监听器。</p>
<table>
<thead>
<tr>
<th style="text-align:center">对象类型</th>
<th style="text-align:center">对应的监听器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ServletContext</td>
<td style="text-align:center">ServletContextListener</td>
</tr>
<tr>
<td style="text-align:center">HttpSession</td>
<td style="text-align:center">HttpSessionListener</td>
</tr>
<tr>
<td style="text-align:center">HttpServletRequest</td>
<td style="text-align:center">ServletRequestListener</td>
</tr>
</tbody>
</table>
<p>二类:  监听三个域对象的属性变更的监听器。(属性添加,属性移除,属性替换)</p>
<table>
<thead>
<tr>
<th style="text-align:center">对象类型</th>
<th style="text-align:center">对应的监听器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ServletContext</td>
<td style="text-align:center">ServletContextAttributeListener</td>
</tr>
<tr>
<td style="text-align:center">HttpServletRequest</td>
<td style="text-align:center">ServletRequestAttributeListener</td>
</tr>
<tr>
<td style="text-align:center">HttpSession</td>
<td style="text-align:center">HttpSessionAttributeListener</td>
</tr>
</tbody>
</table>
<p>三类:  监听HttpSession对象中的JavaBean的状态的改变.(绑定,解除绑定,钝化和活化)</p>
<table>
<thead>
<tr>
<th style="text-align:center">对象类型</th>
<th style="text-align:center">对应的监听器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HttpSession</td>
<td style="text-align:center">HttpSessionBindingListener(绑定,解除绑定)</td>
</tr>
<tr>
<td style="text-align:center">HttpSession</td>
<td style="text-align:center">HttpSessionActivationListener(钝化和活化)</td>
</tr>
</tbody>
</table>
<p>为了更好的展示，我们根据操作对象的不同，来分别介绍以上的8种监听器</p>
<h4 id="对application进行监听"><a href="#对application进行监听" class="headerlink" title="对application进行监听"></a>对application进行监听</h4><p>对application监听，实际上就是对Servletcontext(Servlet 上下文)监听。主要使用ServletContextListener和ServletContextAttributeListener两个接口</p>
<h5 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h5><p>对Servlet上下文状态监听可以使用javax.servlet.ServletContextListener接口，此接口定义的方法如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public void contextInitialized(ServletContextEvent sce)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">容器启动时触发</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public void contextDestroyed(ServletContextEvent sce)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">容器销毁时触发</td>
</tr>
</tbody>
</table>
<p>可以看到，它的两个方法参数都是ServletContextEvent实列，因此，在上下文状态监听操作中，一旦触发了ServletContextListener接口中定义的方法后，我们就可以通过ServletContextEvent进行事件的处理，此事件定义的方法如下所示。</p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public ServletContext getServletContext()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得ServletContext对象</td>
</tr>
</tbody>
</table>
<p>可以看到，我们通过ServletContextEvent的 getServletContext方法就可以取得 ServletContext对象的实列。</p>
<p>下面通过代码来看一下对Servlet上下文状态的监听</p>
<p>ListenerServletContextTest.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对ServletContext进行监听</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerServletContextTest</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"容器初始化"</span> + event.getServletContext().getContextPath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"容器销毁"</span> + event.getServletContext().getContextPath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序需要注意的是在类的上面有个注解@WebListener这个就相当于在web.xml中写入了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">        ListenerServletContextTest</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在本程序的容器初始化和销毁的过程中，分别通过ServletContextEvent事件对象取得ServletContext实列，然后调用getContextPath()方法。所以在容器启动时，后台会输出以下内容。</p>
<p><img src="/2019/03/18/MVC/13.png" alt=""></p>
<p>这里注意一下，当我们的程序中既有Servlet,FIlter,Listener的时候，我们的配置文件web.xml怎么写。</p>
<p> 首先配置过滤器：<code>&lt;filter&gt;</code>,<code>&lt;filter-mapping&gt;</code></p>
<p>再配置监听器: <code>&lt;listener&gt;</code></p>
<p>最后配置简单Servlet：<code>&lt;servlet&gt;,&lt;servlet-mapping&gt;</code></p>
<h5 id="ServletContextAttributeListener"><a href="#ServletContextAttributeListener" class="headerlink" title="ServletContextAttributeListener"></a>ServletContextAttributeListener</h5><p>对Servlet上下文的属性操作监听，可以使用javax.servlet.ServletContextAttributeListener接口，此接口定义的方法，如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public void attributeAdded(ServletContextAttributeEvent scab)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">添加属性时触发</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public void attributeRemoved(ServletContextAttributeEvent scab)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">删除属性时触发</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">public void attributeReplaced(ServletContextAttributeEvent scab)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">替换属性时（重复设置）触发</td>
</tr>
</tbody>
</table>
<p>同样可以看到，它的三个方法参数都是ServletContextAttributeEvent 实列，因此，在上下文属性监听操作中，一旦触发了ServletContextAttributeListener接口中定义的方法后，我们就可以通过ServletContextAttributeEvent进行事件的处理，此事件定义的方法如下所示。</p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public String getName()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得设置的属性的名称</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public Object getValue()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得设置的属性的内容</td>
</tr>
</tbody>
</table>
<p>对Servlet上下文属性监听代码示例</p>
<p>ListenerServletContextAttributeTest.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextAttributeEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextAttributeListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 与add.jsp,remove.jsp,replace.jsp配合演示对Servlet Context上下文属性的监听</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerServletContextAttributeTest</span> <span class="keyword">implements</span> <span class="title">ServletContextAttributeListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletContextAttributeEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"增加属性："</span>+event.getName()+<span class="string">"属性内容："</span>+event.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletContextAttributeEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除属性："</span>+event.getName()+<span class="string">"属性内容："</span>+event.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletContextAttributeEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"替换属性："</span>+event.getName()+<span class="string">"属性内容："</span>+event.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add.jsp</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%--</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Created</span> <span class="attr">by</span> <span class="attr">IntelliJ</span> <span class="attr">IDEA.</span></span></span><br><span class="line"><span class="tag">  <span class="attr">User:</span> <span class="attr">yqh</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Date:</span> <span class="attr">2019</span>/<span class="attr">3</span>/<span class="attr">27</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Time:</span> <span class="attr">21:01</span></span></span><br><span class="line"><span class="tag">  <span class="attr">To</span> <span class="attr">change</span> <span class="attr">this</span> <span class="attr">template</span> <span class="attr">use</span> <span class="attr">File</span> | <span class="attr">Settings</span> | <span class="attr">File</span> <span class="attr">Templates.</span></span></span><br><span class="line"><span class="tag"><span class="attr">--</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>增加属性<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag"><span class="attr">application.setAttribute</span>("<span class="attr">add</span>","新增属性");</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>remove.jsp</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%--</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Created</span> <span class="attr">by</span> <span class="attr">IntelliJ</span> <span class="attr">IDEA.</span></span></span><br><span class="line"><span class="tag">  <span class="attr">User:</span> <span class="attr">yqh</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Date:</span> <span class="attr">2019</span>/<span class="attr">3</span>/<span class="attr">27</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Time:</span> <span class="attr">21:13</span></span></span><br><span class="line"><span class="tag">  <span class="attr">To</span> <span class="attr">change</span> <span class="attr">this</span> <span class="attr">template</span> <span class="attr">use</span> <span class="attr">File</span> | <span class="attr">Settings</span> | <span class="attr">File</span> <span class="attr">Templates.</span></span></span><br><span class="line"><span class="tag"><span class="attr">--</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>删除属性<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag"><span class="attr">application.removeAttribute</span>("<span class="attr">add</span>");</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>replace.jsp</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%--</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Created</span> <span class="attr">by</span> <span class="attr">IntelliJ</span> <span class="attr">IDEA.</span></span></span><br><span class="line"><span class="tag">  <span class="attr">User:</span> <span class="attr">yqh</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Date:</span> <span class="attr">2019</span>/<span class="attr">3</span>/<span class="attr">27</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Time:</span> <span class="attr">21:14</span></span></span><br><span class="line"><span class="tag">  <span class="attr">To</span> <span class="attr">change</span> <span class="attr">this</span> <span class="attr">template</span> <span class="attr">use</span> <span class="attr">File</span> | <span class="attr">Settings</span> | <span class="attr">File</span> <span class="attr">Templates.</span></span></span><br><span class="line"><span class="tag"><span class="attr">--</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>替换属性<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag"><span class="attr">application.setAttribute</span>("<span class="attr">add</span>","再次设置<span class="attr">add</span>属性");</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动Web容器过后，在浏览器依次访问上面三个jsp页面，输出如下</p>
<p><img src="/2019/03/18/MVC/14.png" alt=""></p>
<p>可以看到，我们每次对application对象属性进行操作的事件的确是被监听到的。</p>
<h4 id="对session进行监听"><a href="#对session进行监听" class="headerlink" title="对session进行监听"></a>对session进行监听</h4><p>在监听器中，针对于session的监听操作主要使用HttpSessionListener,HttpSessionAttributeListener和HttpSessionBindingListener接口。</p>
<h5 id="HttpSessionListener"><a href="#HttpSessionListener" class="headerlink" title="HttpSessionListener"></a>HttpSessionListener</h5><p>通过此接口可以对session的状态进行监听，当需要创建或者销毁的时候可以实现 javax.servlet.http.HttpSessionListener接口，此接口定义的方法如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public void sessionCreated(HttpsessionEvent se)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">sessio创建时调用</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public void sessionDestroyed(HttpsessionEvent se)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">sessio销毁时调用</td>
</tr>
</tbody>
</table>
<p>可以看出当session创建或者销毁的时候将产生HttpsessionEvent事件，此接口的方法为</p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public Httpsession getSession()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得当前的session对象</td>
</tr>
</tbody>
</table>
<p>对session的监听的具体代码与application差不多，将前面的理解过后，对session的监听的代码就很写了，这里就不举例了。</p>
<p>这里需要注意的是：每当一个新用户打开一个动态网页过后，服务器就会自动为用户分配session，并且触发HttpSessionListener中的sessionCreated事件，但是在销毁的时候却存在两种可能。</p>
<ul>
<li><p>调用HttpSession的invalidate()方法，让一个session失效</p>
</li>
<li><p>通过配置的session超时时间，session超时时间可以直接在项目的web.xml中配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>5<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上将一个session的超时事件配置成了5分钟，如果一个用户在5分钟后没有与服务器进行交互的话，那么服务器会默认此用户已经离开，会自动注销。如果没有配置超时时间，那么tomcat的默认的超时时间是30分钟</p>
</li>
</ul>
<h5 id="HttpsessionAttributeListener"><a href="#HttpsessionAttributeListener" class="headerlink" title="HttpsessionAttributeListener"></a>HttpsessionAttributeListener</h5><p>同样在session监听中，也可以对他的属性进行监听，这一点与监听上下文属性的道理是一样的，要对session的属性进行监听，则要使用javax.servlet.http.HttpsessionAttributeListener接口完成，此接口定义的方法为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public void attributeAdded(HttpSessionBindingEvent se)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">增加属性时触发</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public void attributeRemoved(HttpSessionBindingEvent se)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">删除属性时触发</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">public void attributeReplaced(HttpSessionBindingEvent se)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">替换属性时触发</td>
</tr>
</tbody>
</table>
<p>同样可以看出此接口的的三个方法都需要一个HttpSessionBindingEvent 对象参数，所以我们可以通过HttpSessionBindingEvent 接口来进行事件的处理，此接口的方法如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public HttpSession getSession()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得session</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public String getName()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得属性的名称</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">public Object getValue()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得属性的内容</td>
</tr>
</tbody>
</table>
<p>同样这里与监听上下文属性的代码差不多，就不在写代码进行实列。</p>
<h5 id="HttpSessionBindingListener"><a href="#HttpSessionBindingListener" class="headerlink" title="HttpSessionBindingListener"></a>HttpSessionBindingListener</h5><p>之前所有介绍的session监听接口都需要在web.xml中配置，或者以注解的形式标明后才可以起作用，但是在web中也提供了一个javax.servlet.http.HttpSessionBindingListener接口，通过此接口实现的监听程序可以不用配置而直接使用，此接口定义的方法如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public void valueBound(HttpSessionBindingEvent event)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">绑定对象到session时触发</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public void valueUnbound(HttpSessionBindingEvent event)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">session中移除对象时触发</td>
</tr>
</tbody>
</table>
<p>下面看一段代码</p>
<p>LoginUser.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Login;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionBindingEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionBindingListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 利用HttpSessionBindingListener对登录用户一对一的监听</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginUser</span> <span class="keyword">implements</span> <span class="title">HttpSessionBindingListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginUser</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username=username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">valueBound</span><span class="params">(HttpSessionBindingEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在session中保存LoginUser对象(name ="</span>+<span class="keyword">this</span>.getUsername()+<span class="string">" ),session id ="</span>+event.getSession().getId());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">valueUnbound</span><span class="params">(HttpSessionBindingEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在session中移除LoginUser对象(name ="</span>+<span class="keyword">this</span>.getUsername()+<span class="string">" ),session id ="</span>+event.getSession().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>session.jsp</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: yqh</span><br><span class="line">  Date: <span class="number">2019</span>/<span class="number">3</span>/<span class="number">27</span></span><br><span class="line">  Time: <span class="number">23</span>:<span class="number">09</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"Login.LoginUser"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;seeion&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">LoginUser user=<span class="keyword">new</span> LoginUser(<span class="string">"yqh"</span>);</span><br><span class="line">session.setAttribute(<span class="string">"login"</span>,user);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>在浏览器输入：<code>http://localhost:8080/session.jsp</code>会在控制台看见 输出如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在session中保存LoginUser对象(name =yqh ),session id =74ECCECACD71DE300A3601A51CFE0AAA</span><br></pre></td></tr></table></figure>
<p>这里需要注意的一个问题就是，虽然HttpSessionBindingListener不需要配置，但是HttpSessionBindingListener他必须需要实例化放入一个session中，才可以监听。从监听范围上比较，HttpSessionListener设置一次就可以监听所有session，HttpSessionBindingListener通常都是一对一的。</p>
<p>正是这种区别成就了HttpSessionBindingListener的优势，我们可以让每个listener对应一个username，这样就不需要每次再去session中读取username，进一步可以将所有操作在线列表的代码都移入listener，更容易维护。</p>
<h4 id="对request进行监听"><a href="#对request进行监听" class="headerlink" title="对request进行监听"></a>对request进行监听</h4><p>对requset操作进行监听，主要使用ServletRequestListener和ServletRequestAttributeListener两个接口。</p>
<h5 id="ServletRequestListener"><a href="#ServletRequestListener" class="headerlink" title="ServletRequestListener"></a>ServletRequestListener</h5><p>ServletRequestListener对请求状态监听，当需要对用户的每一次请求进行监听的时候，可以使用 Javax.servlet.ServletRequestListener接口，该接口定义的方法如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public void requestDestroyed(ServletRequestEvent sre)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">请求开始时调用</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public void requestInitialized(ServletRequestEvent sre)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">请求结束时调用</td>
</tr>
</tbody>
</table>
<p>同样这个接口的方法需要一个ServletRequestEvent类型参数，这个接口的方法如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public ServletRequest getServletRequest()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得ServletRequest对象</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public ServletContext getServletContext()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得ServletContext对象</td>
</tr>
</tbody>
</table>
<p>通过这个接口就取得相应的对象过后，就可以开始相应的操作了。</p>
<h5 id="ServletRequestAttributeListener"><a href="#ServletRequestAttributeListener" class="headerlink" title="ServletRequestAttributeListener"></a>ServletRequestAttributeListener</h5><p>对request范围的属性可以使用javax.servlet.ServletRequestAttributeListener接口进行监听，它的方法如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public void attributeAdded(ServletRequestAttributeEvent srae)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">属性增加时调用</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public void attributeRemoved(ServletRequestAttributeEvent srae)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">属性删除时调用</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">public void attributeReplaced(ServletRequestAttributeEvent srae)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">属性替换时调用</td>
</tr>
</tbody>
</table>
<p>ServletRequestAttributeEvent接口的方法如下</p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public java.lang.String getName()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得设置属性的名称</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public java.lang.Object getValue()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得设置属性的内容</td>
</tr>
</tbody>
</table>
<p>通过这两个接口的配合就可以实现对request操作属性的监听了。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Servlet/" rel="tag"><i class="fa fa-tag"></i> Servlet</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/10/设计模式/" rel="next" title="设计模式">
                <i class="fa fa-chevron-left"></i> 设计模式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/01/Tomcat数据源/" rel="prev" title="Tomcat数据源">
                Tomcat数据源 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  <div class="post-spread">
      
        
                                <div class="-mob-share-ui-button -mob-share-open">分享</div>
                                <div class="-mob-share-ui" style="display: none">
                                    <ul class="-mob-share-list">
                                        <li class="-mob-share-weibo"><p>新浪微博</p></li>
                                        <li class="-mob-share-tencentweibo"><p>腾讯微博</p></li>
                                        <li class="-mob-share-qzone"><p>QQ空间</p></li>
                                        <li class="-mob-share-qq"><p>QQ好友</p></li>
                                        <li class="-mob-share-weixin"><p>微信</p></li>
                                        <li class="-mob-share-douban"><p>豆瓣</p></li>
                                    </ul>
                                    <div class="-mob-share-close">取消</div>
                                </div>
                                <div class="-mob-share-ui-bg"></div>
                                <script id="-mob-share" src="http://f1.webshare.mob.com/code/mob-share.js?appkey=262488aa81530"></script>

								
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="HY" />
            
              <p class="site-author-name" itemprop="name">HY</p>
              <p class="site-description motion-element" itemprop="description">A man is only as good as what he loves.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yqh74110" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yaoqiuhong@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1334259177&auto=0&height=32"></iframe>		
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=436147067&auto=0&height=32"></iframe>	  
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=32431822&auto=0&height=32"></iframe>

          

        </div>
		
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言："><span class="nav-number">1.</span> <span class="nav-text">前言：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MVC"><span class="nav-number">2.</span> <span class="nav-text">MVC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#初阶Servlet"><span class="nav-number">2.1.</span> <span class="nav-text">初阶Servlet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet"><span class="nav-number">2.1.1.</span> <span class="nav-text">Servlet</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#由上图可以看出控制层主要是Servlet，那么什么是Servlet呢？"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">由上图可以看出控制层主要是Servlet，那么什么是Servlet呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Servlet处理的基本流程："><span class="nav-number">2.1.1.2.</span> <span class="nav-text">Servlet处理的基本流程：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关于-HttpServlet、GenericServlet-和-Servlet-的关系"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">关于 HttpServlet、GenericServlet 和 Servlet 的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Servlet-1"><span class="nav-number">2.1.1.3.1.</span> <span class="nav-text">Servlet</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GenericServlet"><span class="nav-number">2.1.1.3.2.</span> <span class="nav-text">GenericServlet</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HttpServlet"><span class="nav-number">2.1.1.3.3.</span> <span class="nav-text">HttpServlet</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Servlet的运行环境"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">Servlet的运行环境</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#示例"><span class="nav-number">2.1.1.4.1.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一般运行步骤"><span class="nav-number">2.1.1.4.2.</span> <span class="nav-text">一般运行步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IDE运行步骤"><span class="nav-number">2.1.1.4.3.</span> <span class="nav-text">IDE运行步骤</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Servlet的生命周期"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">Servlet的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是Servlet的生命周期呢？"><span class="nav-number">2.1.1.5.1.</span> <span class="nav-text">什么是Servlet的生命周期呢？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#各个生命周期的作用"><span class="nav-number">2.1.1.6.</span> <span class="nav-text">各个生命周期的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-加载Servlet"><span class="nav-number">2.1.1.6.1.</span> <span class="nav-text">1. 加载Servlet</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-初始化"><span class="nav-number">2.1.1.6.2.</span> <span class="nav-text">2.初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-处理服务"><span class="nav-number">2.1.1.6.3.</span> <span class="nav-text">3.处理服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-销毁"><span class="nav-number">2.1.1.6.4.</span> <span class="nav-text">4.销毁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-卸载"><span class="nav-number">2.1.1.6.5.</span> <span class="nav-text">5.卸载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-示例"><span class="nav-number">2.1.1.6.6.</span> <span class="nav-text">6.示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Servlet的运行过程"><span class="nav-number">2.1.1.7.</span> <span class="nav-text">Servlet的运行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#过程"><span class="nav-number">2.1.1.7.1.</span> <span class="nav-text">过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#注："><span class="nav-number">2.1.1.7.2.</span> <span class="nav-text">注：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运行过程的补充"><span class="nav-number">2.1.1.8.</span> <span class="nav-text">运行过程的补充</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ServletRequest"><span class="nav-number">2.1.1.8.1.</span> <span class="nav-text">ServletRequest</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ServletResponse"><span class="nav-number">2.1.1.8.2.</span> <span class="nav-text">ServletResponse</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HttpServletRequest"><span class="nav-number">2.1.1.8.3.</span> <span class="nav-text">HttpServletRequest</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HttpServletResponse"><span class="nav-number">2.1.1.8.4.</span> <span class="nav-text">HttpServletResponse</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GenericServlet-1"><span class="nav-number">2.1.1.9.</span> <span class="nav-text">GenericServlet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HttpServlet-1"><span class="nav-number">2.1.1.10.</span> <span class="nav-text">HttpServlet</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet的应用"><span class="nav-number">2.1.2.</span> <span class="nav-text">Servlet的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#取得初始化配置信息"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">取得初始化配置信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#取得其他的内置对象"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">取得其他的内置对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#取得ServletContext实例"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">取得ServletContext实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Servlet跳转"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">Servlet跳转</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#客户端跳转"><span class="nav-number">2.1.2.4.1.</span> <span class="nav-text">客户端跳转</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#服务器跳转"><span class="nav-number">2.1.2.4.2.</span> <span class="nav-text">服务器跳转</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进阶Servlet"><span class="nav-number">2.2.</span> <span class="nav-text">进阶Servlet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Filter"><span class="nav-number">2.2.1.</span> <span class="nav-text">Filter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Filter的基本概念"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">Filter的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Filter如何实现拦截"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">Filter如何实现拦截</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#具体解释："><span class="nav-number">2.2.1.2.1.</span> <span class="nav-text">具体解释：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Filter开发步骤"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">Filter开发步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#第一步"><span class="nav-number">2.2.1.3.1.</span> <span class="nav-text">第一步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#第二步"><span class="nav-number">2.2.1.3.2.</span> <span class="nav-text">第二步</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Filter链"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">Filter链</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现"><span class="nav-number">2.2.1.4.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#注意"><span class="nav-number">2.2.1.4.2.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Filter的生命周期"><span class="nav-number">2.2.1.5.</span> <span class="nav-text">Filter的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FilterConfig"><span class="nav-number">2.2.1.6.</span> <span class="nav-text">FilterConfig</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Filter的应用"><span class="nav-number">2.2.1.7.</span> <span class="nav-text">Filter的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#统一全站的字符编码"><span class="nav-number">2.2.1.7.1.</span> <span class="nav-text">统一全站的字符编码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#登录验证"><span class="nav-number">2.2.1.7.2.</span> <span class="nav-text">登录验证</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XXXListener"><span class="nav-number">2.2.2.</span> <span class="nav-text">XXXListener</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简介"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对application进行监听"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">对application进行监听</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ServletContextListener"><span class="nav-number">2.2.2.2.1.</span> <span class="nav-text">ServletContextListener</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ServletContextAttributeListener"><span class="nav-number">2.2.2.2.2.</span> <span class="nav-text">ServletContextAttributeListener</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对session进行监听"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">对session进行监听</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HttpSessionListener"><span class="nav-number">2.2.2.3.1.</span> <span class="nav-text">HttpSessionListener</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HttpsessionAttributeListener"><span class="nav-number">2.2.2.3.2.</span> <span class="nav-text">HttpsessionAttributeListener</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HttpSessionBindingListener"><span class="nav-number">2.2.2.3.3.</span> <span class="nav-text">HttpSessionBindingListener</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对request进行监听"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">对request进行监听</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ServletRequestListener"><span class="nav-number">2.2.2.4.1.</span> <span class="nav-text">ServletRequestListener</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ServletRequestAttributeListener"><span class="nav-number">2.2.2.4.2.</span> <span class="nav-text">ServletRequestAttributeListener</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HY</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">25.2k</span>
  
</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
